<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GK Visual Tracking (2D)</title>
  <style>
    html, body { margin:0; height:100%; background:#111; font-family: system-ui, -apple-system, Segoe UI, Roboto; }
    #wrap { display:flex; height:100%; align-items:center; justify-content:center; }
    canvas { background:#0b0b0b; border:1px solid #333; touch-action: manipulation; }

    #hud {
      position: fixed; left: 12px; top: 12px; color:#ddd; font-size: 14px;
      background: rgba(0,0,0,.45); padding: 10px 12px; border-radius: 12px; border:1px solid #333;
      max-width: 420px;
    }
    #hud b { color:#fff; }
    #hud .row { margin: 8px 0; }
    #hud kbd { background:#222; border:1px solid #444; padding:2px 6px; border-radius:6px; }
    #bar { height: 6px; background:#222; border:1px solid #444; border-radius: 999px; overflow:hidden; }
    #fill { height:100%; width:0%; background:#fff; }
    button { margin-right: 6px; padding: 6px 10px; background:#1f1f1f; color:#eee; border:1px solid #444; border-radius:10px; }
    button:hover { background:#2a2a2a; cursor:pointer; }

    input[type="range"] { width: 220px; vertical-align: middle; }
    .small { opacity:.85; font-size: 12px; line-height: 1.2; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c" width="900" height="520"></canvas>
  </div>

  <div id="hud">
    <div class="row"><b>GK Visual Tracking</b> (2D) — DIY</div>

    <div class="row">
      <button id="startBtn">Nouvel essai</button>
      <button id="revealBtn">Révéler</button>
    </div>

    <div class="row">Phase: <b id="phase">—</b></div>
    <div class="row">Score: <b id="score">0</b> / <b id="trials">0</b></div>
    <div class="row">Temps: <b id="time">0.00</b> s</div>
    <div class="row" id="instr">Espace = nouvel essai. Quand STOP → Espace = révéler.</div>

    <div class="row">
      Vitesse: <b id="speedVal"></b>
      <input id="speed" type="range" min="60" max="520" step="10" />
    </div>

    <div class="row">
      Durée mouvement (s): <b id="moveVal"></b>
      <input id="move" type="range" min="2" max="20" step="1" />
    </div>

    <div class="row">
      Cible visible (ms): <b id="cueVal"></b>
      <input id="cue" type="range" min="300" max="2500" step="100" />
    </div>

    <div class="row">
      Nb objets: <b id="nVal"></b>
      <input id="nDots" type="range" min="4" max="20" step="1" />
    </div>

    <div class="row">
      Chaos: <b id="chaosVal"></b>
      <input id="chaos" type="range" min="0" max="0.9" step="0.05" />
    </div>

    <div id="bar"><div id="fill"></div></div>

    <div class="row small">
      Raccourcis: <kbd>Espace</kbd> nouvel essai • (en STOP) <kbd>Espace</kbd> révèle • <kbd>R</kbd> révèle
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // ====== PARAMÈTRES (modifiable via sliders) ======
  const CONFIG = {
    nDots: 10,
    radius: 14,
    chaos: 0.35,
    speed: 260,
    showTargetMs: 900,
    moveMs: 7000,     // durée de mouvement après la phase "cible visible"
    bounce: true,
  };

  // ====== UI ======
  const phaseEl = document.getElementById('phase');
  const scoreEl = document.getElementById('score');
  const trialsEl = document.getElementById('trials');
  const timeEl = document.getElementById('time');
  const fillEl = document.getElementById('fill');
  const startBtn = document.getElementById('startBtn');
  const revealBtn = document.getElementById('revealBtn');
  const instrEl = document.getElementById('instr');

  const speedSlider = document.getElementById('speed');
  const moveSlider  = document.getElementById('move');
  const cueSlider   = document.getElementById('cue');
  const nSlider     = document.getElementById('nDots');
  const chaosSlider = document.getElementById('chaos');

  const speedValEl = document.getElementById('speedVal');
  const moveValEl  = document.getElementById('moveVal');
  const cueValEl   = document.getElementById('cueVal');
  const nValEl     = document.getElementById('nVal');
  const chaosValEl = document.getElementById('chaosVal');

  function syncControlsFromConfig() {
    speedSlider.value = CONFIG.speed;
    moveSlider.value  = Math.round(CONFIG.moveMs / 1000);
    cueSlider.value   = CONFIG.showTargetMs;
    nSlider.value     = CONFIG.nDots;
    chaosSlider.value = CONFIG.chaos;

    speedValEl.textContent = CONFIG.speed;
    moveValEl.textContent  = (CONFIG.moveMs / 1000).toFixed(0);
    cueValEl.textContent   = CONFIG.showTargetMs;
    nValEl.textContent     = CONFIG.nDots;
    chaosValEl.textContent = CONFIG.chaos.toFixed(2);
  }

  function applyControlsToConfig() {
    CONFIG.speed = parseInt(speedSlider.value, 10);
    CONFIG.moveMs = parseInt(moveSlider.value, 10) * 1000;
    CONFIG.showTargetMs = parseInt(cueSlider.value, 10);
    CONFIG.nDots = parseInt(nSlider.value, 10);
    CONFIG.chaos = parseFloat(chaosSlider.value);

    speedValEl.textContent = CONFIG.speed;
    moveValEl.textContent  = (CONFIG.moveMs / 1000).toFixed(0);
    cueValEl.textContent   = CONFIG.showTargetMs;
    nValEl.textContent     = CONFIG.nDots;
    chaosValEl.textContent = CONFIG.chaos.toFixed(2);
  }

  speedSlider.addEventListener('input', applyControlsToConfig);
  moveSlider.addEventListener('input', applyControlsToConfig);
  cueSlider.addEventListener('input', applyControlsToConfig);
  nSlider.addEventListener('input', applyControlsToConfig);
  chaosSlider.addEventListener('input', applyControlsToConfig);

  // ====== état ======
  let dots = [];
  let targetId = 0;
  let phase = 'idle'; // idle | cue | uniform | waiting | stopped | revealed
  let t0 = 0;
  let last = 0;
  let score = 0;
  let trials = 0;
  let answerLocked = false;
  let reveal = false;

  // couleurs
  const BG = '#0b0b0b';
  const DOT = '#e6e6e6';
  const TARGET_CUE = '#ff3b30'; // cible différente au début
  const REVEAL_OK = '#34c759';

  function rand(min, max) { return Math.random() * (max - min) + min; }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function resizeToFit() {
    const maxW = window.innerWidth - 20;
    const maxH = window.innerHeight - 20;
    const aspect = 900/520;

    let w = Math.min(900, maxW);
    let h = w / aspect;
    if (h > maxH) { h = Math.min(520, maxH); w = h * aspect; }

    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', resizeToFit);
  resizeToFit();

  function initTrial() {
    applyControlsToConfig(); // prend les réglages courants à chaque essai

    trials++;
    trialsEl.textContent = trials;
    answerLocked = false;
    reveal = false;

    const W = canvas.width, H = canvas.height;
    dots = [];
    for (let i = 0; i < CONFIG.nDots; i++) {
      const angle = rand(0, Math.PI * 2);
      const sp = rand(CONFIG.speed * 0.75, CONFIG.speed * 1.25);
      dots.push({
        id: i,
        x: rand(CONFIG.radius, W - CONFIG.radius),
        y: rand(CONFIG.radius, H - CONFIG.radius),
        vx: Math.cos(angle) * sp,
        vy: Math.sin(angle) * sp,
      });
    }
    targetId = Math.floor(rand(0, CONFIG.nDots));

    phase = 'cue';
    phaseEl.textContent = 'CIBLE VISIBLE';
    instrEl.textContent = "Mémorise la cible (rouge), puis elle devient identique.";
    t0 = performance.now();
    last = t0;

    requestAnimationFrame(loop);
  }

  function revealTarget() {
    reveal = true;
    phase = 'revealed';
    phaseEl.textContent = 'RÉVÉLATION';
    instrEl.textContent = "Cible révélée. Espace = nouvel essai.";
  }

  function step(dt) {
    const W = canvas.width, H = canvas.height;

    for (const d of dots) {
      // errance (chaos)
      d.vx += rand(-1, 1) * CONFIG.chaos * 60;
      d.vy += rand(-1, 1) * CONFIG.chaos * 60;

      // maintien vitesse
      const sp = Math.hypot(d.vx, d.vy) || 1;
      const desired = CONFIG.speed;
      d.vx = (d.vx / sp) * (desired + rand(-20, 20));
      d.vy = (d.vy / sp) * (desired + rand(-20, 20));

      d.x += d.vx * dt;
      d.y += d.vy * dt;

      if (CONFIG.bounce) {
        if (d.x < CONFIG.radius) { d.x = CONFIG.radius; d.vx *= -1; }
        if (d.x > W - CONFIG.radius) { d.x = W - CONFIG.radius; d.vx *= -1; }
        if (d.y < CONFIG.radius) { d.y = CONFIG.radius; d.vy *= -1; }
        if (d.y > H - CONFIG.radius) { d.y = H - CONFIG.radius; d.vy *= -1; }
      } else {
        if (d.x < -CONFIG.radius) d.x = W + CONFIG.radius;
        if (d.x > W + CONFIG.radius) d.x = -CONFIG.radius;
        if (d.y < -CONFIG.radius) d.y = H + CONFIG.radius;
        if (d.y > H + CONFIG.radius) d.y = -CONFIG.radius;
      }
    }
  }

  function draw(now) {
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0, 0, W, H);

    ctx.fillStyle = BG;
    ctx.fillRect(0, 0, W, H);

    const elapsed = (now - t0) / 1000;
    timeEl.textContent = elapsed.toFixed(2);

    // barre = progression jusqu'au STOP
    const totalMsToStop = CONFIG.showTargetMs + CONFIG.moveMs;
    const p = clamp((now - t0) / totalMsToStop, 0, 1);
    fillEl.style.width = (p * 100).toFixed(1) + '%';

    for (const d of dots) {
      let color = DOT;
      if (phase === 'cue' && d.id === targetId) color = TARGET_CUE;
      if (reveal && d.id === targetId) color = REVEAL_OK;

      ctx.beginPath();
      ctx.arc(d.x, d.y, CONFIG.radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();

      ctx.lineWidth = 2;
      ctx.strokeStyle = '#111';
      ctx.stroke();
    }

    ctx.fillStyle = 'rgba(255,255,255,.85)';
    ctx.font = '18px system-ui, -apple-system, Segoe UI, Roboto';

    if (phase === 'cue') ctx.fillText('Cible visible (rouge)', 18, 32);
    if (phase === 'uniform' || phase === 'waiting') ctx.fillText('Tout identique — suis la cible', 18, 32);
    if (phase === 'stopped') ctx.fillText('STOP — appuie sur ESPACE pour révéler', 18, 32);
    if (phase === 'revealed') ctx.fillText('Cible révélée', 18, 32);
  }

  function loop(now) {
    const dt = (now - last) / 1000;
    last = now;

    const ms = now - t0;

    // cue -> uniform
    if (phase === 'cue' && ms >= CONFIG.showTargetMs) {
      phase = 'waiting';
      phaseEl.textContent = 'TRACKING';
      instrEl.textContent = "Tout est identique. Suis la cible jusqu'au STOP.";
    }

    // mouvement uniquement tant que pas STOP
    if (!answerLocked) {
      if (phase === 'cue' || phase === 'waiting') step(dt);
    }

    // STOP après durée définie (showTargetMs + moveMs)
    if (phase === 'waiting' && ms >= (CONFIG.showTargetMs + CONFIG.moveMs)) {
      phase = 'stopped';
      phaseEl.textContent = 'STOP';
      instrEl.textContent = "STOP — Appuie sur ESPACE pour révéler.";
    }

    draw(now);

    if (phase !== 'idle') requestAnimationFrame(loop);
  }

  // Clique/tap = on désactive volontairement la réponse (tu voulais révélation coach)
  // Si tu veux remettre le clic du gardien plus tard, dis-moi et je te le réactive proprement.

  // Boutons
  startBtn.addEventListener('click', initTrial);
  revealBtn.addEventListener('click', () => {
    if (phase === 'stopped' && !reveal) revealTarget();
  });

  // Clavier
  document.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();

    if (e.code === 'Space') {
      e.preventDefault();
      if (phase === 'stopped' && !reveal) {
        revealTarget();
      } else {
        initTrial();
      }
    }
    if (k === 'r') {
      if (phase === 'stopped' && !reveal) revealTarget();
    }
  });

  // init UI + premier essai
  syncControlsFromConfig();
  applyControlsToConfig();
  initTrial();
})();
</script>
</body>
</html>
