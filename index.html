<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GK Visual Lab — Xamax</title>
  <style>
    :root{
      --xamax-red:#e10600;
      --bg:#0b0b0b;
      --panel: rgba(10,10,10,.72);
      --stroke:#242424;
      --text:#e9e9e9;
      --muted:#bdbdbd;
    }
    html, body { margin:0; height:100%; background:#070707; font-family: system-ui, -apple-system, Segoe UI, Roboto; color:var(--text); }
    #wrap { display:flex; height:100%; align-items:center; justify-content:center; padding:12px; }
    canvas { background:var(--bg); border:1px solid var(--stroke); border-radius:18px; touch-action: none; }

    #topbar{
      position: fixed; left: 12px; right:12px; top: 12px;
      display:flex; align-items:center; justify-content:space-between;
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius: 16px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 10;
    }
    #brand{ display:flex; align-items:center; gap:10px; min-width: 0; }
    #brand img{ height:28px; width:auto; display:block; }
    #brand .title{ font-weight: 850; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    #brand .subtitle{ font-size:12px; color:var(--muted); margin-top:1px; }

    .btn{
      padding: 8px 10px;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border:1px solid var(--stroke);
      border-radius: 12px;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn.primary{
      background: rgba(225,6,0,.22);
      border-color: rgba(225,6,0,.55);
    }
    .btn.primary:hover{ background: rgba(225,6,0,.30); }

    #drawer{
      position: fixed; right: 12px; top: 64px;
      width: 420px;
      max-width: calc(100vw - 24px);
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius: 16px;
      padding: 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 10;
      transform: translateY(-6px);
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s ease, transform .15s ease;
    }
    #drawer.open{ opacity: 1; transform: translateY(0); pointer-events: auto; }

    .row{ margin: 10px 0; }
    .rowline{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .label{ color: var(--muted); font-size:12px; }
    .val{ font-weight: 850; }
    input[type="range"]{ width: 230px; }
    select{
      width: 230px;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border:1px solid var(--stroke);
      border-radius: 12px;
      padding: 8px 10px;
      outline: none;
    }

    #mini{
      position: fixed; left: 12px; bottom: 12px;
      background: rgba(10,10,10,.55);
      border:1px solid var(--stroke);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 9;
      max-width: calc(100vw - 24px);
    }
    #mini .kpi{ display:flex; gap:14px; flex-wrap:wrap; align-items:baseline; }
    #mini b{ color:#fff; }
    #bar { height: 6px; background: rgba(255,255,255,.08); border:1px solid var(--stroke); border-radius: 999px; overflow:hidden; margin-top:8px; }
    #fill { height:100%; width:0%; background: var(--xamax-red); }

    .hint{ font-size:12px; color: var(--muted); margin-top:6px; line-height: 1.25; }
    kbd { background: rgba(255,255,255,.06); border:1px solid var(--stroke); padding:2px 6px; border-radius:8px; color:#fff; }

    #overlay{
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.65);
      z-index: 20;
      padding: 18px;
    }
    #card{
      width: 600px; max-width: calc(100vw - 36px);
      background: rgba(10,10,10,.86);
      border:1px solid var(--stroke);
      border-radius: 18px;
      padding: 16px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #card h2{ margin: 0 0 8px 0; font-size: 18px; }
    #card p{ margin: 6px 0; color: var(--muted); font-size: 13px; line-height: 1.35; }
    #err{
      display:none;
      margin-top:10px;
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid rgba(225,6,0,.55);
      background: rgba(225,6,0,.10);
      color: #fff;
      font-size: 12px;
      white-space: pre-wrap;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      font-size: 12px;
      color: var(--text);
      margin-top: 8px;
      flex-wrap:wrap;
    }
  </style>
</head>

<body>
  <div id="wrap">
    <canvas id="c" width="1200" height="720"></canvas>
  </div>

  <div id="topbar">
    <div id="brand">
      <img id="logo" alt="Logo" />
      <div style="min-width:0">
        <div class="title">GK Visual Lab</div>
        <div class="subtitle" id="subtitle">Tap / clic = Start • Stop • Reveal</div>
      </div>
    </div>
    <div style="display:flex; gap:8px; align-items:center;">
      <button class="btn primary" id="startBtn">Démarrer</button>
      <button class="btn primary" id="revealBtn" style="display:none;">Reveal</button>
      <button class="btn" id="toggleBtn">☰</button>
    </div>
  </div>

  <div id="drawer">
    <div class="rowline">
      <div>
        <div style="font-weight:850">Menu</div>
        <div class="label">Mini-jeu + réglages</div>
      </div>
      <button class="btn" id="stopBtn">Stop</button>
    </div>

    <div class="row">
      <div class="rowline">
        <div>
          <div class="label">Mini-jeu</div>
          <div class="val"><span id="modeVal"></span></div>
        </div>
        <select id="mode">
          <option value="tracker">Tracker (MOT)</option>
          <option value="grid">Visual Search (chaos)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div class="rowline">
        <div>
          <div class="label">Vitesse</div>
          <div class="val"><span id="speedVal"></span></div>
        </div>
        <input id="speed" type="range" min="40" max="600" step="10" />
      </div>
    </div>

    <div class="row">
      <div class="rowline">
        <div>
          <div class="label">Durée mouvement (s)</div>
          <div class="val"><span id="moveVal"></span></div>
        </div>
        <input id="move" type="range" min="2" max="25" step="1" />
      </div>
    </div>

    <div class="row">
      <div class="rowline">
        <div>
          <div class="label">Taille éléments</div>
          <div class="val"><span id="sizeVal"></span> px</div>
        </div>
        <input id="size" type="range" min="10" max="34" step="1" />
      </div>
    </div>

    <div class="row">
      <div class="rowline" style="margin-bottom:6px">
        <div>
          <div class="label">Croix centrale</div>
          <div class="val"><span id="fixVal"></span></div>
        </div>
        <select id="fixation">
          <option value="off" selected>Off</option>
          <option value="on">On</option>
        </select>
      </div>

      <div class="rowline">
        <div>
          <div class="label">Gamification (RT STOP→Reveal)</div>
          <div class="val"><span id="gameVal"></span></div>
        </div>
        <select id="gamify">
          <option value="off" selected>Off</option>
          <option value="on">On</option>
        </select>
      </div>
    </div>

    <div class="row" id="trackerBlock">
      <div class="rowline" style="margin-bottom:6px">
        <div>
          <div class="label">Tracker — variante</div>
          <div class="val"><span id="stimVal"></span></div>
        </div>
        <select id="stimulus">
          <option value="color">Cible en couleur</option>
          <option value="number">Numéros (puis masqués)</option>
        </select>
      </div>

      <div class="rowline">
        <div>
          <div class="label">Cue visible (ms)</div>
          <div class="val"><span id="cueVal"></span></div>
        </div>
        <input id="cue" type="range" min="300" max="2500" step="100" />
      </div>

      <div class="rowline" style="margin-top:10px">
        <div>
          <div class="label">Nb billes</div>
          <div class="val"><span id="nVal"></span></div>
        </div>
        <input id="nDots" type="range" min="4" max="24" step="1" />
      </div>

      <div class="rowline" style="margin-top:10px">
        <div>
          <div class="label">Nb cibles (1–4)</div>
          <div class="val"><span id="tVal"></span></div>
        </div>
        <input id="nTargets" type="range" min="1" max="4" step="1" />
      </div>

      <div class="rowline" style="margin-top:10px">
        <div>
          <div class="label">Chaos</div>
          <div class="val"><span id="chaosVal"></span></div>
        </div>
        <input id="chaos" type="range" min="0" max="0.9" step="0.05" />
      </div>

      <div class="hint">
        Astuce: en phase REVEAL, un tap/clic prépare un nouvel essai (sans démarrer).
      </div>
    </div>

    <div class="row" id="gridBlock" style="display:none">
      <div class="rowline">
        <div>
          <div class="label">Taille grille</div>
          <div class="val"><span id="gridVal"></span></div>
        </div>
        <select id="gridSize">
          <option value="4">4×4</option>
          <option value="5" selected>5×5</option>
          <option value="6">6×6</option>
        </select>
      </div>
    </div>

    <div class="hint">
      Tap / clic sur le terrain = action. <kbd>ESPACE</kbd> aussi. <kbd>M</kbd> menu. <kbd>N</kbd> nouvel essai.
    </div>
  </div>

  <div id="mini">
    <div class="kpi">
      <div>Mode: <b id="modeMini">—</b></div>
      <div>Phase: <b id="phase">READY</b></div>
      <div>Essais: <b id="trials">0</b></div>
      <div>Temps: <b id="time">0.00</b>s</div>
    </div>

    <div class="pill" id="scorePill" style="display:none;">
      <span>RT:</span> <b id="rtLast">—</b>
      <span style="opacity:.6">|</span>
      <span>Best:</span> <b id="rtBest">—</b>
      <span style="opacity:.6">|</span>
      <span>Moy:</span> <b id="rtAvg">—</b>
    </div>

    <div id="bar"><div id="fill"></div></div>
  </div>

  <div id="overlay">
    <div id="card">
      <h2>GK Visual Lab — prêt</h2>
      <p><b>Démarrer</b> ou tap/clic sur le terrain. STOP est automatique. Ensuite <b>Reveal</b> (bouton ou tap/clic).</p>
      <div style="display:flex; gap:10px; margin-top:12px; flex-wrap:wrap;">
        <button class="btn primary" id="overlayStart">Démarrer</button>
        <button class="btn" id="overlayMenu">Ouvrir menu</button>
      </div>
      <div id="err"></div>
    </div>
  </div>

<script>
(() => {
  // Logo optionnel
  const LOGO_PATH = "xamaxlogo.png";
  const logoEl = document.getElementById('logo');
  logoEl.onerror = () => { logoEl.style.display = "none"; };
  if (LOGO_PATH) logoEl.src = LOGO_PATH; else logoEl.style.display = "none";

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const subtitleEl = document.getElementById('subtitle');
  const toggleBtn = document.getElementById('toggleBtn');
  const drawer = document.getElementById('drawer');

  const startBtn = document.getElementById('startBtn');
  const revealBtn = document.getElementById('revealBtn');
  const stopBtn = document.getElementById('stopBtn');

  const overlay = document.getElementById('overlay');
  const overlayStart = document.getElementById('overlayStart');
  const overlayMenu = document.getElementById('overlayMenu');
  const errBox = document.getElementById('err');

  const modeSel = document.getElementById('mode');
  const modeVal = document.getElementById('modeVal');
  const modeMini = document.getElementById('modeMini');

  const phaseEl = document.getElementById('phase');
  const trialsEl = document.getElementById('trials');
  const timeEl = document.getElementById('time');
  const fillEl = document.getElementById('fill');

  const speedSlider = document.getElementById('speed');
  const moveSlider  = document.getElementById('move');
  const sizeSlider  = document.getElementById('size');
  const speedValEl = document.getElementById('speedVal');
  const moveValEl  = document.getElementById('moveVal');
  const sizeValEl  = document.getElementById('sizeVal');

  const fixationSel = document.getElementById('fixation');
  const fixValEl = document.getElementById('fixVal');
  const gamifySel = document.getElementById('gamify');
  const gameValEl = document.getElementById('gameVal');

  const trackerBlock = document.getElementById('trackerBlock');
  const stimulusSel = document.getElementById('stimulus');
  const stimValEl = document.getElementById('stimVal');
  const cueSlider = document.getElementById('cue');
  const cueValEl  = document.getElementById('cueVal');
  const nSlider   = document.getElementById('nDots');
  const nValEl    = document.getElementById('nVal');
  const tSlider   = document.getElementById('nTargets');
  const tValEl    = document.getElementById('tVal');
  const chaosSlider = document.getElementById('chaos');
  const chaosValEl  = document.getElementById('chaosVal');

  const gridBlock = document.getElementById('gridBlock');
  const gridSizeSel = document.getElementById('gridSize');
  const gridValEl = document.getElementById('gridVal');

  const scorePill = document.getElementById('scorePill');
  const rtLastEl = document.getElementById('rtLast');
  const rtBestEl = document.getElementById('rtBest');
  const rtAvgEl  = document.getElementById('rtAvg');

  const CONFIG = {
    mode: 'tracker',
    speed: 260,
    moveMs: 7000,
    size: 18,
    fixation: 'off',
    gamify: 'off',

    stimulus: 'color',
    showTargetMs: 900,
    nDots: 10,
    nTargets: 1,
    chaos: 0.35,

    gridN: 5,
  };

  let running = false;
  let phase = 'READY'; // READY | CUE | TRACK | STOP | REVEAL
  let trials = 0;
  let t0 = 0;
  let last = 0;

  let dots = [];
  let targetIds = [];
  let grid = [];

  // anti double-trigger
  let lastActionAt = 0;

  // gamify
  let stopAt = null;
  let rtLast = null;
  let rtBest = null;
  let rtSum = 0;
  let rtCount = 0;

  const BG = '#0b0b0b';
  const DOT = '#e6e6e6';
  const TARGET_CUE = '#e10600'; // rouge
  const REVEAL_RING = '#34c759'; // contour vert

  function rand(min, max) { return Math.random() * (max - min) + min; }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function randomBrightColor(){
    const h = (Math.random()*360)|0;
    return `hsl(${h} 85% 60%)`;
  }

  function setError(msg){
    errBox.style.display = "block";
    errBox.textContent = msg;
  }

  function fmtMs(ms){
    if (ms == null) return '—';
    return `${Math.round(ms)} ms`;
  }

  function updateScoreUI(){
    if (CONFIG.gamify !== 'on'){
      scorePill.style.display = 'none';
      return;
    }
    scorePill.style.display = 'inline-flex';
    rtLastEl.textContent = fmtMs(rtLast);
    rtBestEl.textContent = fmtMs(rtBest);
    const avg = (rtCount > 0) ? (rtSum / rtCount) : null;
    rtAvgEl.textContent = fmtMs(avg);
  }

  function updateActionButtons(){
    revealBtn.style.display = (!running && phase === 'STOP') ? 'inline-flex' : 'none';
  }

  function syncUI(){
    modeSel.value = CONFIG.mode;
    modeVal.textContent = CONFIG.mode === 'tracker' ? 'Tracker' : 'Visual Search';
    modeMini.textContent = modeVal.textContent;

    speedSlider.value = CONFIG.speed;
    moveSlider.value  = Math.round(CONFIG.moveMs/1000);
    sizeSlider.value  = CONFIG.size;
    speedValEl.textContent = CONFIG.speed;
    moveValEl.textContent  = (CONFIG.moveMs/1000).toFixed(0);
    sizeValEl.textContent  = CONFIG.size;

    fixationSel.value = CONFIG.fixation;
    fixValEl.textContent = (CONFIG.fixation === 'on') ? 'On' : 'Off';

    gamifySel.value = CONFIG.gamify;
    gameValEl.textContent = (CONFIG.gamify === 'on') ? 'On' : 'Off';

    stimulusSel.value = CONFIG.stimulus;
    stimValEl.textContent = CONFIG.stimulus === 'color' ? 'Couleur' : 'Numéros';
    cueSlider.value = CONFIG.showTargetMs;
    cueValEl.textContent = CONFIG.showTargetMs;
    nSlider.value = CONFIG.nDots;
    nValEl.textContent = CONFIG.nDots;
    tSlider.value = CONFIG.nTargets;
    tValEl.textContent = CONFIG.nTargets;
    chaosSlider.value = CONFIG.chaos;
    chaosValEl.textContent = CONFIG.chaos.toFixed(2);

    gridSizeSel.value = String(CONFIG.gridN);
    gridValEl.textContent = `${CONFIG.gridN}×${CONFIG.gridN}`;

    trackerBlock.style.display = (CONFIG.mode === 'tracker') ? 'block' : 'none';
    gridBlock.style.display = (CONFIG.mode === 'grid') ? 'block' : 'none';

    subtitleEl.textContent = running ? 'En cours (tap/clic = Stop)' : 'Tap/clic = Start • Stop • Reveal';

    updateScoreUI();
    updateActionButtons();
  }

  function applyFromControls(){
    CONFIG.mode = modeSel.value;
    CONFIG.speed = parseInt(speedSlider.value, 10);
    CONFIG.moveMs = parseInt(moveSlider.value, 10) * 1000;
    CONFIG.size = parseInt(sizeSlider.value, 10);

    CONFIG.fixation = fixationSel.value;
    CONFIG.gamify = gamifySel.value;

    CONFIG.stimulus = stimulusSel.value;
    CONFIG.showTargetMs = parseInt(cueSlider.value, 10);
    CONFIG.nDots = parseInt(nSlider.value, 10);
    CONFIG.nTargets = parseInt(tSlider.value, 10);
    CONFIG.chaos = parseFloat(chaosSlider.value);

    CONFIG.gridN = parseInt(gridSizeSel.value, 10);

    syncUI();
  }

  [
    modeSel, speedSlider, moveSlider, sizeSlider,
    fixationSel, gamifySel,
    stimulusSel, cueSlider, nSlider, tSlider, chaosSlider,
    gridSizeSel
  ].forEach(el => el.addEventListener('input', applyFromControls));

  toggleBtn.addEventListener('click', () => drawer.classList.toggle('open'));

  function resizeToFit(){
    const topOffset = 84;
    const bottomOffset = 120;
    const sideOffset = 24;

    const maxW = window.innerWidth - sideOffset;
    const maxH = window.innerHeight - topOffset - bottomOffset;

    const aspect = canvas.width / canvas.height;
    let w = maxW;
    let h = w / aspect;
    if (h > maxH) { h = maxH; w = h * aspect; }

    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', resizeToFit);
  resizeToFit();

  function buildTracker(){
    dots = [];
    const W = canvas.width, H = canvas.height;
    for (let i=0;i<CONFIG.nDots;i++){
      const angle = rand(0, Math.PI*2);
      const sp = rand(CONFIG.speed*0.75, CONFIG.speed*1.25);
      dots.push({
        id:i,
        x: rand(CONFIG.size, W-CONFIG.size),
        y: rand(CONFIG.size, H-CONFIG.size),
        vx: Math.cos(angle)*sp,
        vy: Math.sin(angle)*sp,
        label: String(i+1)
      });
    }
    const pool = [...Array(CONFIG.nDots).keys()];
    for (let i = pool.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    targetIds = pool.slice(0, Math.min(CONFIG.nTargets, CONFIG.nDots));
  }

  function pickChaosTexts(n){
    const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ";
    const out = [];
    for (let i=0;i<n;i++){
      if (Math.random() < 0.5) out.push(String((Math.random()*10)|0));
      else out.push(alphabet[(Math.random()*alphabet.length)|0]);
    }
    return out;
  }

  function buildGrid(){
    grid = [];
    const N = CONFIG.gridN;
    const W = canvas.width, H = canvas.height;

    const pad = 18;
    const usableW = W - pad*2;
    const usableH = H - pad*2;

    const cellW = usableW / N;
    const cellH = usableH / N;

    const texts = pickChaosTexts(N*N);

    let k = 0;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const x0 = pad + c*cellW + cellW/2;
        const y0 = pad + r*cellH + cellH/2;
        const angle = rand(0, Math.PI*2);
        const sp = rand(CONFIG.speed*0.15, CONFIG.speed*0.40);
        grid.push({
          x:x0, y:y0,
          vx: Math.cos(angle)*sp,
          vy: Math.sin(angle)*sp,
          text: texts[k],
          color: randomBrightColor()
        });
        k++;
      }
    }
  }

  function resetGamifyTrial(){
    stopAt = null;
  }

  function newTrial(){
    applyFromControls();
    trials++;
    trialsEl.textContent = trials;

    phase = 'READY';
    running = false;
    phaseEl.textContent = phase;
    fillEl.style.width = '0%';
    timeEl.textContent = '0.00';
    overlay.style.display = 'flex';

    resetGamifyTrial();

    if (CONFIG.mode === 'tracker') buildTracker();
    else buildGrid();

    draw(performance.now());
    syncUI();
  }

  function startRun(){
    overlay.style.display = 'none';
    running = true;
    t0 = performance.now();
    last = t0;
    phase = 'CUE';
    phaseEl.textContent = phase;
    resetGamifyTrial();
    requestAnimationFrame(loop);
    syncUI();
  }

  function stopRun(now){
    running = false;
    phase = 'STOP';
    phaseEl.textContent = phase;
    stopAt = now ?? performance.now();
    syncUI();
    draw(performance.now());
  }

  function reveal(now){
    phase = 'REVEAL';
    phaseEl.textContent = phase;

    if (CONFIG.gamify === 'on' && stopAt != null){
      const rt = (now ?? performance.now()) - stopAt;
      rtLast = rt;
      rtBest = (rtBest == null) ? rt : Math.min(rtBest, rt);
      rtSum += rt;
      rtCount += 1;
    }
    updateScoreUI();
    syncUI();
    draw(performance.now());
  }

  function safeAction(now){
    // anti double trigger (double click / trackpad / pointer quirks)
    if (now - lastActionAt < 250) return;
    lastActionAt = now;
    handleAction(now);
  }

  function handleAction(now){
    if (running) { stopRun(now); return; }
    if (phase === 'STOP') { reveal(now); return; }
    if (phase === 'REVEAL') { newTrial(); return; } // IMPORTANT: ne redémarre pas
    if (phase === 'READY') { startRun(); return; }
    // fallback
    newTrial();
  }

  function stepTracker(dt){
    const W = canvas.width, H = canvas.height;
    for (const d of dots){
      d.vx += rand(-1,1)*CONFIG.chaos*60;
      d.vy += rand(-1,1)*CONFIG.chaos*60;

      const sp = Math.hypot(d.vx,d.vy) || 1;
      const desired = CONFIG.speed;
      d.vx = (d.vx/sp)*(desired + rand(-20,20));
      d.vy = (d.vy/sp)*(desired + rand(-20,20));

      d.x += d.vx*dt;
      d.y += d.vy*dt;

      if (d.x < CONFIG.size) { d.x = CONFIG.size; d.vx *= -1; }
      if (d.x > W-CONFIG.size) { d.x = W-CONFIG.size; d.vx *= -1; }
      if (d.y < CONFIG.size) { d.y = CONFIG.size; d.vy *= -1; }
      if (d.y > H-CONFIG.size) { d.y = H-CONFIG.size; d.vy *= -1; }
    }
  }

  function stepGrid(dt){
    const W = canvas.width, H = canvas.height;
    const pad = 22;
    for (const cell of grid){
      cell.x += cell.vx*dt;
      cell.y += cell.vy*dt;

      if (cell.x < pad) { cell.x = pad; cell.vx *= -1; }
      if (cell.x > W-pad) { cell.x = W-pad; cell.vx *= -1; }
      if (cell.y < pad) { cell.y = pad; cell.vy *= -1; }
      if (cell.y > H-pad) { cell.y = H-pad; cell.vy *= -1; }
    }
  }

  function drawFixationCross(){
    if (CONFIG.fixation !== 'on') return;
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const s = Math.max(10, Math.floor(CONFIG.size * 1.1));
    ctx.save();
    ctx.globalAlpha = 0.78;
    ctx.strokeStyle = 'rgba(255,255,255,.88)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx - s, cy); ctx.lineTo(cx + s, cy);
    ctx.moveTo(cx, cy - s); ctx.lineTo(cx, cy + s);
    ctx.stroke();
    ctx.restore();
  }

  function draw(now){
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = BG;
    ctx.fillRect(0,0,W,H);

    if (running){
      const elapsed = (now - t0) / 1000;
      timeEl.textContent = elapsed.toFixed(2);

      const cueMs = (CONFIG.mode === 'tracker') ? CONFIG.showTargetMs : 700;
      const totalMsToStop = cueMs + CONFIG.moveMs;
      const p = clamp((now - t0) / totalMsToStop, 0, 1);
      fillEl.style.width = (p*100).toFixed(1)+'%';
    }

    ctx.fillStyle = 'rgba(255,255,255,.85)';
    ctx.font = '22px system-ui, -apple-system, Segoe UI, Roboto';
    if (!running && phase === 'READY') ctx.fillText('Prêt — Démarrer / tap', 24, 44);
    if (phase === 'STOP') ctx.fillText('STOP — Reveal (bouton ou tap)', 24, 44);
    if (phase === 'REVEAL') ctx.fillText('RÉVÉLATION — tap pour nouvel essai', 24, 44);

    if (CONFIG.mode === 'tracker') drawTracker();
    else drawGrid();

    drawFixationCross();
  }

  function drawTracker(){
    const showCue = (phase === 'CUE');
    const showNumbers = (CONFIG.stimulus === 'number') && showCue;

    for (const d of dots){
      let color = DOT;

      // Cue (mode couleur) : cible(s) rouges
      if (showCue && targetIds.includes(d.id) && CONFIG.stimulus === 'color'){
        color = TARGET_CUE;
      }

      // Reveal : on revoit les cibles en ROUGE + contour VERT (hyper lisible)
      const isTarget = targetIds.includes(d.id);
      if (phase === 'REVEAL' && isTarget){
        color = TARGET_CUE;
      }

      ctx.beginPath();
      ctx.arc(d.x, d.y, CONFIG.size, 0, Math.PI*2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#111';
      ctx.stroke();

      // contour vert en reveal pour les cibles
      if (phase === 'REVEAL' && isTarget){
        ctx.lineWidth = 4;
        ctx.strokeStyle = REVEAL_RING;
        ctx.stroke();
      }

      // Numéros : plus gras + contour (lisibilité)
      if (showNumbers){
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const fs = Math.max(14, Math.floor(CONFIG.size * 1.15));
        ctx.font = `800 ${fs}px system-ui, -apple-system, Segoe UI, Roboto`;

        // contour clair
        ctx.lineWidth = 4;
        ctx.strokeStyle = 'rgba(255,255,255,.85)';
        ctx.strokeText(d.label, d.x, d.y+1);

        // remplissage sombre
        ctx.fillStyle = '#111';
        ctx.fillText(d.label, d.x, d.y+1);
        ctx.restore();
      }
    }

    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = 'rgba(255,255,255,.70)';
    ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto';

    if (phase === 'CUE'){
      if (CONFIG.stimulus === 'color') ctx.fillText('Mémorise les cibles rouges', 24, canvas.height-24);
      else ctx.fillText('Mémorise les numéros des cibles', 24, canvas.height-24);
    } else if (phase === 'TRACK'){
      ctx.fillText('Tracking — tout identique', 24, canvas.height-24);
    } else if (phase === 'REVEAL'){
      ctx.fillText('Cibles = rouge + contour vert', 24, canvas.height-24);
    }
  }

  function drawGrid(){
    for (const cell of grid){
      ctx.beginPath();
      ctx.roundRect(cell.x - (CONFIG.size*2.0), cell.y - (CONFIG.size*1.25),
                    CONFIG.size*4.0, CONFIG.size*2.5, 14);
      ctx.fillStyle = 'rgba(255,255,255,.05)';
      ctx.fill();
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = 'rgba(255,255,255,.08)';
      ctx.stroke();

      ctx.fillStyle = cell.color;
      ctx.font = `${Math.max(14, CONFIG.size)}px system-ui, -apple-system, Segoe UI, Roboto`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(cell.text, cell.x, cell.y);
    }
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
  }

  function loop(now){
    if (!running) { draw(now); return; }

    const dt = (now - last)/1000;
    last = now;
    const ms = now - t0;

    if (CONFIG.mode === 'tracker'){
      if (phase === 'CUE' && ms >= CONFIG.showTargetMs){
        phase = 'TRACK';
        phaseEl.textContent = phase;
      }
      if (phase === 'CUE' || phase === 'TRACK') stepTracker(dt);
      if (phase === 'TRACK' && ms >= (CONFIG.showTargetMs + CONFIG.moveMs)) stopRun(now);
    } else {
      const gridCueMs = 700;
      if (phase === 'CUE' && ms >= gridCueMs){
        phase = 'TRACK';
        phaseEl.textContent = phase;
      }
      if (phase === 'CUE' || phase === 'TRACK') stepGrid(dt);
      if (phase === 'TRACK' && ms >= (gridCueMs + CONFIG.moveMs)) stopRun(now);
    }

    draw(now);
    if (running) requestAnimationFrame(loop);
  }

  // ===== Controls (robust) =====
  startBtn.addEventListener('click', () => safeAction(performance.now()));
  revealBtn.addEventListener('click', () => safeAction(performance.now()));

  stopBtn.addEventListener('click', () => {
    const now = performance.now();
    if (running) stopRun(now);
    else if (phase === 'STOP') reveal(now);
  });

  overlayStart.addEventListener('click', () => startRun());
  overlayMenu.addEventListener('click', () => drawer.classList.add('open'));

  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    safeAction(performance.now());
  }, { passive:false });

  document.addEventListener('keydown', (e) => {
    const key = e.key;
    const code = e.code;
    if (code === 'Space' || key === ' ' || key === 'Spacebar'){
      e.preventDefault();
      safeAction(performance.now());
    }
    const k = (key || '').toLowerCase();
    if (k === 'm') drawer.classList.toggle('open');
    if (k === 'n') newTrial();
  });

  if (!ctx.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  window.addEventListener('error', (ev) => {
    setError(`Erreur JS détectée:\n${ev.message}\n${ev.filename}:${ev.lineno}`);
  });

  modeSel.addEventListener('change', () => { applyFromControls(); newTrial(); });

  function initDefaults(){
    speedSlider.value = CONFIG.speed;
    moveSlider.value = Math.round(CONFIG.moveMs/1000);
    sizeSlider.value = CONFIG.size;

    fixationSel.value = CONFIG.fixation;
    gamifySel.value = CONFIG.gamify;

    stimulusSel.value = CONFIG.stimulus;
    cueSlider.value = CONFIG.showTargetMs;
    nSlider.value = CONFIG.nDots;
    tSlider.value = CONFIG.nTargets;
    chaosSlider.value = CONFIG.chaos;

    gridSizeSel.value = String(CONFIG.gridN);
  }

  initDefaults();
  applyFromControls();
  newTrial();
})();
</script>
</body>
</html>
