<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>GK Visual Lab — Xamax</title>
  <style>
    :root{
      --xamax-red:#e10600;
      --bg:#0b0b0b;
      --panel: rgba(10,10,10,.72);
      --stroke:#242424;
      --text:#e9e9e9;
      --muted:#bdbdbd;
    }
    html, body { margin:0; height:100%; background:#070707; font-family: system-ui, -apple-system, Segoe UI, Roboto; color:var(--text); }
    body{ overflow:hidden; }

    /* ✅ Canvas plein écran sur toutes les machines */
    canvas{
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      background: var(--bg);
      border: 0;
      border-radius: 0;
      touch-action: none;
      display:block;
    }

    #topbar{
      position: fixed; left: 12px; right:12px; top: 12px;
      display:flex; align-items:center; justify-content:space-between;
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius: 16px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 10;
    }
    #brand{ display:flex; align-items:center; gap:10px; min-width: 0; }
    #brand img{ height:28px; width:auto; display:block; }
    #brand .title{ font-weight: 850; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    #brand .subtitle{ font-size:12px; color:var(--muted); margin-top:1px; }

    .btn{
      padding: 8px 10px;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border:1px solid var(--stroke);
      border-radius: 12px;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn.primary{
      background: rgba(225,6,0,.22);
      border-color: rgba(225,6,0,.55);
    }
    .btn.primary:hover{ background: rgba(225,6,0,.30); }

    #drawer{
      position: fixed; right: 12px; top: 64px;
      width: 440px;
      max-width: calc(100vw - 24px);
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius: 16px;
      padding: 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 10;
      transform: translateY(-6px);
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s ease, transform .15s ease;
    }
    #drawer.open{ opacity: 1; transform: translateY(0); pointer-events: auto; }

    .row{ margin: 10px 0; }
    .rowline{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .label{ color: var(--muted); font-size:12px; }
    .val{ font-weight: 850; }
    input[type="range"]{ width: 230px; }
    select{
      width: 230px;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border:1px solid var(--stroke);
      border-radius: 12px;
      padding: 8px 10px;
      outline: none;
    }

    #mini{
      position: fixed; left: 12px; bottom: 12px;
      background: rgba(10,10,10,.55);
      border:1px solid var(--stroke);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 9;
      max-width: calc(100vw - 24px);
    }
    #mini .kpi{ display:flex; gap:14px; flex-wrap:wrap; align-items:baseline; }
    #mini b{ color:#fff; }
    #bar { height: 6px; background: rgba(255,255,255,.08); border:1px solid var(--stroke); border-radius: 999px; overflow:hidden; margin-top:8px; }
    #fill { height:100%; width:0%; background: var(--xamax-red); }

    .hint{ font-size:12px; color: var(--muted); margin-top:6px; line-height: 1.25; }
    kbd { background: rgba(255,255,255,.06); border:1px solid var(--stroke); padding:2px 6px; border-radius:8px; color:#fff; }

    #overlay{
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.65);
      z-index: 20;
      padding: 18px;
    }
    #card{
      width: 640px; max-width: calc(100vw - 36px);
      background: rgba(10,10,10,.86);
      border:1px solid var(--stroke);
      border-radius: 18px;
      padding: 16px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #card h2{ margin: 0 0 8px 0; font-size: 18px; }
    #card p{ margin: 6px 0; color: var(--muted); font-size: 13px; line-height: 1.35; }
    #err{
      display:none;
      margin-top:10px;
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid rgba(225,6,0,.55);
      background: rgba(225,6,0,.10);
      color: #fff;
      font-size: 12px;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div id="topbar">
    <div id="brand">
      <img id="logo" alt="Logo" />
      <div style="min-width:0">
        <div class="title">GK Visual Lab</div>
        <div class="subtitle" id="subtitle">Tap/clic = Start • Stop • Reveal</div>
      </div>
    </div>
    <div style="display:flex; gap:8px; align-items:center;">
      <button class="btn primary" id="startBtn">Démarrer</button>
      <button class="btn primary" id="revealBtn" style="display:none;">Reveal</button>
      <button class="btn" id="toggleBtn">☰</button>
    </div>
  </div>

  <div id="drawer">
    <div class="rowline">
      <div>
        <div style="font-weight:850">Menu</div>
        <div class="label">Mini-jeu + réglages</div>
      </div>
      <button class="btn" id="stopBtn">Stop</button>
    </div>

    <div class="row">
      <div class="rowline">
        <div>
          <div class="label">Mini-jeu</div>
          <div class="val"><span id="modeVal"></span></div>
        </div>
        <select id="mode">
          <option value="tracker">Tracker (MOT)</option>
          <option value="grid">Grille (visual chaos)</option>
          <option value="colors">Couleurs (alternance)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div class="rowline">
        <div>
          <div class="label">Vitesse</div>
          <div class="val"><span id="speedVal"></span></div>
        </div>
        <input id="speed" type="range" min="40" max="600" step="10" />
      </div>
    </div>

    <div class="row">
      <div class="rowline">
        <div>
          <div class="label">Durée mouvement (s)</div>
          <div class="val"><span id="moveVal"></span></div>
        </div>
        <input id="move" type="range" min="2" max="25" step="1" />
      </div>
    </div>

    <div class="row">
      <div class="rowline">
        <div>
          <div class="label">Taille éléments</div>
          <div class="val"><span id="sizeVal"></span> px</div>
        </div>
        <input id="size" type="range" min="10" max="34" step="1" />
      </div>
    </div>

    <div class="row">
      <div class="rowline" style="margin-bottom:6px">
        <div>
          <div class="label">Croix centrale</div>
          <div class="val"><span id="fixVal"></span></div>
        </div>
        <select id="fixation">
          <option value="off" selected>Off</option>
          <option value="on">On</option>
        </select>
      </div>

      <div class="rowline">
        <div>
          <div class="label">Gamification (RT STOP→Reveal)</div>
          <div class="val"><span id="gameVal"></span></div>
        </div>
        <select id="gamify">
          <option value="off" selected>Off</option>
          <option value="on">On</option>
        </select>
      </div>
    </div>

    <!-- Tracker -->
    <div class="row" id="trackerBlock">
      <div class="rowline" style="margin-bottom:6px">
        <div>
          <div class="label">Tracker — variante</div>
          <div class="val"><span id="stimVal"></span></div>
        </div>
        <select id="stimulus">
          <option value="color">Cible en couleur</option>
          <option value="number">Numéros (puis masqués)</option>
        </select>
      </div>

      <div class="rowline">
        <div>
          <div class="label">Temps stable au départ (s)</div>
          <div class="val"><span id="preVal"></span></div>
        </div>
        <input id="preMove" type="range" min="0" max="5" step="0.5" />
      </div>

      <div class="rowline" style="margin-top:10px">
        <div>
          <div class="label">Nb billes</div>
          <div class="val"><span id="nVal"></span></div>
        </div>
        <input id="nDots" type="range" min="4" max="24" step="1" />
      </div>

      <div class="rowline" style="margin-top:10px">
        <div>
          <div class="label">Nb cibles (1–4)</div>
          <div class="val"><span id="tVal"></span></div>
        </div>
        <input id="nTargets" type="range" min="1" max="4" step="1" />
      </div>

      <div class="rowline" style="margin-top:10px">
        <div>
          <div class="label">Chaos</div>
          <div class="val"><span id="chaosVal"></span></div>
        </div>
        <input id="chaos" type="range" min="0" max="0.9" step="0.05" />
      </div>

      <div class="hint">
        En tracker : d'abord stable (cibles visibles), puis seulement le mouvement commence.
      </div>
    </div>

    <!-- Grid -->
    <div class="row" id="gridBlock" style="display:none">
      <div class="rowline">
        <div>
          <div class="label">Taille grille</div>
          <div class="val"><span id="gridVal"></span></div>
        </div>
        <select id="gridSize">
          <option value="4">4×4</option>
          <option value="5" selected>5×5</option>
          <option value="6">6×6</option>
        </select>
      </div>

      <div class="rowline" style="margin-top:10px">
        <div>
          <div class="label">Couleurs</div>
          <div class="val"><span id="gridColorVal"></span></div>
        </div>
        <select id="gridColorMode">
          <option value="multi" selected>Multi</option>
          <option value="mono">Mono</option>
        </select>
      </div>

      <div class="hint">
        Mono = plus dur (moins d'indices de groupement par couleur).
      </div>
    </div>

    <!-- Colors -->
    <div class="row" id="colorsBlock" style="display:none">
      <div class="rowline">
        <div>
          <div class="label">Intervalle changement (s)</div>
          <div class="val"><span id="colIntVal"></span></div>
        </div>
        <input id="colorInterval" type="range" min="0.10" max="2.50" step="0.05" />
      </div>
      <div class="hint">
        Défile à l'infini. Start = lance, Stop = fige. Tap/clic = Start/Stop.
      </div>
    </div>

    <div class="hint">
      Tap/clic sur le terrain = action. <kbd>ESPACE</kbd> aussi. <kbd>M</kbd> menu. <kbd>N</kbd> nouvel essai.
    </div>
  </div>

  <div id="mini">
    <div class="kpi">
      <div>Mode: <b id="modeMini">—</b></div>
      <div>Phase: <b id="phase">READY</b></div>
      <div>Essais: <b id="trials">0</b></div>
      <div>Temps: <b id="time">0.00</b>s</div>
    </div>

    <div class="pill" id="scorePill" style="display:none;">
      <span>RT:</span> <b id="rtLast">—</b>
      <span style="opacity:.6">|</span>
      <span>Best:</span> <b id="rtBest">—</b>
      <span style="opacity:.6">|</span>
      <span>Moy:</span> <b id="rtAvg">—</b>
    </div>

    <div id="bar"><div id="fill"></div></div>
  </div>

  <div id="overlay">
    <div id="card">
      <h2>GK Visual Lab — prêt</h2>
      <p>Start = tap/clic ou bouton. STOP est automatique (sauf mode Couleurs). Ensuite Reveal (bouton ou tap/clic).</p>
      <div style="display:flex; gap:10px; margin-top:12px; flex-wrap:wrap;">
        <button class="btn primary" id="overlayStart">Démarrer</button>
        <button class="btn" id="overlayMenu">Ouvrir menu</button>
      </div>
      <div id="err"></div>
    </div>
  </div>

<script>
(() => {
  // Logo optionnel
  const LOGO_PATH = "xamaxlogo.png";
  const logoEl = document.getElementById('logo');
  logoEl.onerror = () => { logoEl.style.display = "none"; };
  if (LOGO_PATH) logoEl.src = LOGO_PATH; else logoEl.style.display = "none";

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const subtitleEl = document.getElementById('subtitle');
  const toggleBtn = document.getElementById('toggleBtn');
  const drawer = document.getElementById('drawer');

  const startBtn = document.getElementById('startBtn');
  const revealBtn = document.getElementById('revealBtn');
  const stopBtn = document.getElementById('stopBtn');

  const overlay = document.getElementById('overlay');
  const overlayStart = document.getElementById('overlayStart');
  const overlayMenu = document.getElementById('overlayMenu');
  const errBox = document.getElementById('err');

  const modeSel = document.getElementById('mode');
  const modeVal = document.getElementById('modeVal');
  const modeMini = document.getElementById('modeMini');

  const phaseEl = document.getElementById('phase');
  const trialsEl = document.getElementById('trials');
  const timeEl = document.getElementById('time');
  const fillEl = document.getElementById('fill');

  const speedSlider = document.getElementById('speed');
  const moveSlider  = document.getElementById('move');
  const sizeSlider  = document.getElementById('size');
  const speedValEl = document.getElementById('speedVal');
  const moveValEl  = document.getElementById('moveVal');
  const sizeValEl  = document.getElementById('sizeVal');

  const fixationSel = document.getElementById('fixation');
  const fixValEl = document.getElementById('fixVal');
  const gamifySel = document.getElementById('gamify');
  const gameValEl = document.getElementById('gameVal');

  const trackerBlock = document.getElementById('trackerBlock');
  const stimulusSel = document.getElementById('stimulus');
  const stimValEl = document.getElementById('stimVal');
  const preMoveSlider = document.getElementById('preMove');
  const preValEl = document.getElementById('preVal');
  const nSlider   = document.getElementById('nDots');
  const nValEl    = document.getElementById('nVal');
  const tSlider   = document.getElementById('nTargets');
  const tValEl    = document.getElementById('tVal');
  const chaosSlider = document.getElementById('chaos');
  const chaosValEl  = document.getElementById('chaosVal');

  const gridBlock = document.getElementById('gridBlock');
  const gridSizeSel = document.getElementById('gridSize');
  const gridValEl = document.getElementById('gridVal');
  const gridColorModeSel = document.getElementById('gridColorMode');
  const gridColorValEl = document.getElementById('gridColorVal');

  const colorsBlock = document.getElementById('colorsBlock');
  const colorIntervalSlider = document.getElementById('colorInterval');
  const colIntValEl = document.getElementById('colIntVal');

  const scorePill = document.getElementById('scorePill');
  const rtLastEl = document.getElementById('rtLast');
  const rtBestEl = document.getElementById('rtBest');
  const rtAvgEl  = document.getElementById('rtAvg');

  const CONFIG = {
    mode: 'tracker',
    speed: 260,
    moveMs: 7000,
    size: 18,
    fixation: 'off',
    gamify: 'off',

    stimulus: 'color',
    preMoveMs: 2000,
    nDots: 10,
    nTargets: 1,
    chaos: 0.35,

    gridN: 5,
    gridColorMode: 'multi',

    colorIntervalMs: 300, // ✅ mini-jeu couleurs (infinite)
  };

  let running = false;
  let phase = 'READY'; // READY | CUE | TRACK | STOP | REVEAL
  let trials = 0;
  let t0 = 0;
  let last = 0;

  let dots = [];
  let targetIds = [];
  let grid = [];

  let lastActionAt = 0;

  // gamify
  let stopAt = null;
  let rtLast = null;
  let rtBest = null;
  let rtSum = 0;
  let rtCount = 0;

  const DOT = '#e6e6e6';
  const TARGET_CUE = '#e10600';
  const REVEAL_RING = '#34c759';

  // ✅ Couleurs mini-jeu 3
  const COLOR_SET = [
    { name:'Blanc', value:'#FFFFFF' },
    { name:'Bleu',  value:'#1E90FF' },
    { name:'Rouge', value:'#E10600' },
    { name:'Jaune', value:'#FFD400' },
  ];
  let currentColor = COLOR_SET[0].value;
  let currentColorName = COLOR_SET[0].name;
  let lastColorChangeAt = 0;

  function rand(min, max) { return Math.random() * (max - min) + min; }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function randomBrightColor(){
    const h = (Math.random()*360)|0;
    return `hsl(${h} 85% 60%)`;
  }

  function setError(msg){
    errBox.style.display = "block";
    errBox.textContent = msg;
  }

  function fmtMs(ms){
    if (ms == null) return '—';
    return `${Math.round(ms)} ms`;
  }

  function updateScoreUI(){
    if (CONFIG.gamify !== 'on'){
      scorePill.style.display = 'none';
      return;
    }
    scorePill.style.display = 'inline-flex';
    rtLastEl.textContent = fmtMs(rtLast);
    rtBestEl.textContent = fmtMs(rtBest);
    const avg = (rtCount > 0) ? (rtSum / rtCount) : null;
    rtAvgEl.textContent = fmtMs(avg);
  }

  function updateActionButtons(){
    // Reveal seulement pour tracker/grid (pas pour colors)
    const allowReveal = (CONFIG.mode !== 'colors');
    revealBtn.style.display = (allowReveal && !running && phase === 'STOP') ? 'inline-flex' : 'none';
  }

  function syncUI(){
    modeSel.value = CONFIG.mode;
    modeVal.textContent =
      CONFIG.mode === 'tracker' ? 'Tracker' :
      CONFIG.mode === 'grid' ? 'Grille' : 'Couleurs';
    modeMini.textContent = modeVal.textContent;

    speedSlider.value = CONFIG.speed;
    moveSlider.value  = Math.round(CONFIG.moveMs/1000);
    sizeSlider.value  = CONFIG.size;
    speedValEl.textContent = CONFIG.speed;
    moveValEl.textContent  = (CONFIG.moveMs/1000).toFixed(0);
    sizeValEl.textContent  = CONFIG.size;

    fixationSel.value = CONFIG.fixation;
    fixValEl.textContent = (CONFIG.fixation === 'on') ? 'On' : 'Off';

    gamifySel.value = CONFIG.gamify;
    gameValEl.textContent = (CONFIG.gamify === 'on') ? 'On' : 'Off';

    stimulusSel.value = CONFIG.stimulus;
    stimValEl.textContent = CONFIG.stimulus === 'color' ? 'Couleur' : 'Numéros';

    preMoveSlider.value = (CONFIG.preMoveMs/1000);
    preValEl.textContent = (CONFIG.preMoveMs/1000).toFixed(1);

    nSlider.value = CONFIG.nDots;
    nValEl.textContent = CONFIG.nDots;
    tSlider.value = CONFIG.nTargets;
    tValEl.textContent = CONFIG.nTargets;
    chaosSlider.value = CONFIG.chaos;
    chaosValEl.textContent = CONFIG.chaos.toFixed(2);

    gridSizeSel.value = String(CONFIG.gridN);
    gridValEl.textContent = `${CONFIG.gridN}×${CONFIG.gridN}`;

    gridColorModeSel.value = CONFIG.gridColorMode;
    gridColorValEl.textContent = (CONFIG.gridColorMode === 'mono') ? 'Mono' : 'Multi';

    colorIntervalSlider.value = (CONFIG.colorIntervalMs/1000).toFixed(2);
    colIntValEl.textContent = (CONFIG.colorIntervalMs/1000).toFixed(2);

    trackerBlock.style.display = (CONFIG.mode === 'tracker') ? 'block' : 'none';
    gridBlock.style.display = (CONFIG.mode === 'grid') ? 'block' : 'none';
    colorsBlock.style.display = (CONFIG.mode === 'colors') ? 'block' : 'none';

    // Subtitle logique
    if (CONFIG.mode === 'colors'){
      subtitleEl.textContent = running ? 'Couleurs: en cours (tap/clic = Stop)' : 'Couleurs: tap/clic = Start/Stop';
    } else {
      subtitleEl.textContent = running ? 'En cours (tap/clic = Stop)' : 'Tap/clic = Start • Stop • Reveal';
    }

    updateScoreUI();
    updateActionButtons();
  }

  function applyFromControls(){
    CONFIG.mode = modeSel.value;

    CONFIG.speed = parseInt(speedSlider.value, 10);
    CONFIG.moveMs = parseInt(moveSlider.value, 10) * 1000;
    CONFIG.size = parseInt(sizeSlider.value, 10);

    CONFIG.fixation = fixationSel.value;
    CONFIG.gamify = gamifySel.value;

    CONFIG.stimulus = stimulusSel.value;
    CONFIG.preMoveMs = Math.round(parseFloat(preMoveSlider.value) * 1000);
    CONFIG.nDots = parseInt(nSlider.value, 10);
    CONFIG.nTargets = parseInt(tSlider.value, 10);
    CONFIG.chaos = parseFloat(chaosSlider.value);

    CONFIG.gridN = parseInt(gridSizeSel.value, 10);
    CONFIG.gridColorMode = gridColorModeSel.value;

    CONFIG.colorIntervalMs = Math.round(parseFloat(colorIntervalSlider.value) * 1000);

    syncUI();
  }

  [
    modeSel, speedSlider, moveSlider, sizeSlider,
    fixationSel, gamifySel,
    stimulusSel, preMoveSlider, nSlider, tSlider, chaosSlider,
    gridSizeSel, gridColorModeSel,
    colorIntervalSlider
  ].forEach(el => el.addEventListener('input', applyFromControls));

  toggleBtn.addEventListener('click', () => drawer.classList.toggle('open'));

  // ✅ Canvas vrai plein écran (pixels réels + DPI)
  function resizeCanvas(){
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    canvas.width = w;
    canvas.height = h;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr); // on dessine en "CSS pixels"
    draw(performance.now());
  }
  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('orientationchange', resizeCanvas);

  function buildTracker(){
    dots = [];
    const W = window.innerWidth, H = window.innerHeight;
    for (let i=0;i<CONFIG.nDots;i++){
      const angle = rand(0, Math.PI*2);
      const sp = rand(CONFIG.speed*0.75, CONFIG.speed*1.25);
      dots.push({
        id:i,
        x: rand(CONFIG.size, W-CONFIG.size),
        y: rand(CONFIG.size, H-CONFIG.size),
        vx: Math.cos(angle)*sp,
        vy: Math.sin(angle)*sp,
        label: String(i+1)
      });
    }
    const pool = [...Array(CONFIG.nDots).keys()];
    for (let i = pool.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    targetIds = pool.slice(0, Math.min(CONFIG.nTargets, CONFIG.nDots));
  }

  function pickChaosTexts(n){
    const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ";
    const out = [];
    for (let i=0;i<n;i++){
      if (Math.random() < 0.5) out.push(String((Math.random()*10)|0));
      else out.push(alphabet[(Math.random()*alphabet.length)|0]);
    }
    return out;
  }

  function buildGrid(){
    grid = [];
    const N = CONFIG.gridN;
    const W = window.innerWidth, H = window.innerHeight;

    const pad = 24;
    const usableW = W - pad*2;
    const usableH = H - pad*2;

    const cellW = usableW / N;
    const cellH = usableH / N;

    const texts = pickChaosTexts(N*N);
    const monoColor = randomBrightColor();

    let k = 0;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const x0 = pad + c*cellW + cellW/2;
        const y0 = pad + r*cellH + cellH/2;
        const angle = rand(0, Math.PI*2);
        const sp = rand(CONFIG.speed*0.15, CONFIG.speed*0.40);
        grid.push({
          x:x0, y:y0,
          vx: Math.cos(angle)*sp,
          vy: Math.sin(angle)*sp,
          text: texts[k],
          color: (CONFIG.gridColorMode === 'mono') ? monoColor : randomBrightColor()
        });
        k++;
      }
    }
  }

  function resetGamifyTrial(){
    stopAt = null;
  }

  function newTrial(){
    applyFromControls();
    trials++;
    trialsEl.textContent = trials;

    phase = 'READY';
    running = false;
    phaseEl.textContent = phase;
    fillEl.style.width = '0%';
    timeEl.textContent = '0.00';
    overlay.style.display = 'flex';

    resetGamifyTrial();

    if (CONFIG.mode === 'tracker') buildTracker();
    else if (CONFIG.mode === 'grid') buildGrid();
    else {
      // colors
      const pick = COLOR_SET[(Math.random()*COLOR_SET.length)|0];
      currentColor = pick.value;
      currentColorName = pick.name;
      lastColorChangeAt = performance.now();
    }

    draw(performance.now());
    syncUI();
  }

  function startRun(){
    overlay.style.display = 'none';
    running = true;
    t0 = performance.now();
    last = t0;
    phase = (CONFIG.mode === 'colors') ? 'TRACK' : 'CUE';
    phaseEl.textContent = phase;
    resetGamifyTrial();

    if (CONFIG.mode === 'colors'){
      lastColorChangeAt = t0;
      // on force une première couleur aléatoire au start
      const pick = COLOR_SET[(Math.random()*COLOR_SET.length)|0];
      currentColor = pick.value;
      currentColorName = pick.name;
    }

    requestAnimationFrame(loop);
    syncUI();
  }

  function stopRun(now){
    running = false;
    phase = 'STOP';
    phaseEl.textContent = phase;
    stopAt = now ?? performance.now();
    syncUI();
    draw(performance.now());
  }

  function reveal(now){
    phase = 'REVEAL';
    phaseEl.textContent = phase;

    if (CONFIG.gamify === 'on' && stopAt != null){
      const rt = (now ?? performance.now()) - stopAt;
      rtLast = rt;
      rtBest = (rtBest == null) ? rt : Math.min(rtBest, rt);
      rtSum += rt;
      rtCount += 1;
    }
    updateScoreUI();
    syncUI();
    draw(performance.now());
  }

  function safeAction(now){
    if (now - lastActionAt < 250) return;
    lastActionAt = now;
    handleAction(now);
  }

  function handleAction(now){
    if (running) { stopRun(now); return; }

    // mode colors : Start/Stop en boucle, pas de reveal
    if (CONFIG.mode === 'colors'){
      if (phase === 'STOP' || phase === 'READY') { startRun(); return; }
      if (phase === 'REVEAL') { newTrial(); return; }
      newTrial();
      return;
    }

    // tracker/grid classique
    if (phase === 'STOP') { reveal(now); return; }
    if (phase === 'REVEAL') { newTrial(); return; }
    if (phase === 'READY') { startRun(); return; }
    newTrial();
  }

  function stepTracker(dt){
    const W = window.innerWidth, H = window.innerHeight;
    for (const d of dots){
      d.vx += rand(-1,1)*CONFIG.chaos*60;
      d.vy += rand(-1,1)*CONFIG.chaos*60;

      const sp = Math.hypot(d.vx,d.vy) || 1;
      const desired = CONFIG.speed;
      d.vx = (d.vx/sp)*(desired + rand(-20,20));
      d.vy = (d.vy/sp)*(desired + rand(-20,20));

      d.x += d.vx*dt;
      d.y += d.vy*dt;

      if (d.x < CONFIG.size) { d.x = CONFIG.size; d.vx *= -1; }
      if (d.x > W-CONFIG.size) { d.x = W-CONFIG.size; d.vx *= -1; }
      if (d.y < CONFIG.size) { d.y = CONFIG.size; d.vy *= -1; }
      if (d.y > H-CONFIG.size) { d.y = H-CONFIG.size; d.vy *= -1; }
    }
  }

  function stepGrid(dt){
    const W = window.innerWidth, H = window.innerHeight;
    const pad = 28;
    for (const cell of grid){
      cell.x += cell.vx*dt;
      cell.y += cell.vy*dt;

      if (cell.x < pad) { cell.x = pad; cell.vx *= -1; }
      if (cell.x > W-pad) { cell.x = W-pad; cell.vx *= -1; }
      if (cell.y < pad) { cell.y = pad; cell.vy *= -1; }
      if (cell.y > H-pad) { cell.y = H-pad; cell.vy *= -1; }
    }
  }

  function drawFixationCross(){
    if (CONFIG.fixation !== 'on') return;
    const cx = window.innerWidth / 2;
    const cy = window.innerHeight / 2;
    const s = Math.max(10, Math.floor(CONFIG.size * 1.1));
    ctx.save();
    ctx.globalAlpha = 0.78;
    ctx.strokeStyle = 'rgba(255,255,255,.88)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx - s, cy); ctx.lineTo(cx + s, cy);
    ctx.moveTo(cx, cy - s); ctx.lineTo(cx, cy + s);
    ctx.stroke();
    ctx.restore();
  }

  function draw(now){
    const W = window.innerWidth, H = window.innerHeight;

    // Mode 3: plein écran couleurs
    if (CONFIG.mode === 'colors'){
      ctx.fillStyle = currentColor;
      ctx.fillRect(0,0,W,H);

      // petite info discrète
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto';
      ctx.fillText(`Couleur: ${currentColorName}`, 18, H - 22);

      drawFixationCross();
      return;
    }

    // Tracker/grid classiques
    ctx.fillStyle = '#0b0b0b';
    ctx.fillRect(0,0,W,H);

    if (running){
      const elapsed = (now - t0) / 1000;
      timeEl.textContent = elapsed.toFixed(2);

      const cueMs = (CONFIG.mode === 'tracker') ? CONFIG.preMoveMs : 700;
      const totalMsToStop = cueMs + CONFIG.moveMs;
      const p = clamp((now - t0) / totalMsToStop, 0, 1);
      fillEl.style.width = (p*100).toFixed(1)+'%';
    }

    ctx.fillStyle = 'rgba(255,255,255,.85)';
    ctx.font = '22px system-ui, -apple-system, Segoe UI, Roboto';
    if (!running && phase === 'READY') ctx.fillText('Prêt — Démarrer / tap', 24, 44);
    if (phase === 'CUE') ctx.fillText('CUE — stable', 24, 44);
    if (phase === 'STOP') ctx.fillText('STOP — Reveal', 24, 44);
    if (phase === 'REVEAL') ctx.fillText('RÉVÉLATION — tap pour nouvel essai', 24, 44);

    if (CONFIG.mode === 'tracker') drawTracker();
    else drawGrid();

    drawFixationCross();
  }

  function drawTracker(){
    const showCue = (phase === 'CUE');

    for (const d of dots){
      let color = DOT;
      const isTarget = targetIds.includes(d.id);

      if (showCue && isTarget && CONFIG.stimulus === 'color'){
        color = TARGET_CUE;
      }
      if (phase === 'REVEAL' && isTarget){
        color = TARGET_CUE;
      }

      ctx.beginPath();
      ctx.arc(d.x, d.y, CONFIG.size, 0, Math.PI*2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#111';
      ctx.stroke();

      if (phase === 'REVEAL' && isTarget){
        ctx.lineWidth = 4;
        ctx.strokeStyle = REVEAL_RING;
        ctx.stroke();
      }

      if (showCue && CONFIG.stimulus === 'number'){
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const fs = Math.max(14, Math.floor(CONFIG.size * 1.15));
        ctx.font = `800 ${fs}px system-ui, -apple-system, Segoe UI, Roboto`;

        ctx.lineWidth = 4;
        ctx.strokeStyle = 'rgba(255,255,255,.85)';
        ctx.strokeText(d.label, d.x, d.y+1);

        ctx.fillStyle = '#111';
        ctx.fillText(d.label, d.x, d.y+1);
        ctx.restore();
      }
    }

    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = 'rgba(255,255,255,.70)';
    ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto';

    if (phase === 'CUE'){
      if (CONFIG.stimulus === 'color') ctx.fillText('Mémorise les cibles rouges (stable)', 24, window.innerHeight-24);
      else ctx.fillText('Mémorise les numéros des cibles (stable)', 24, window.innerHeight-24);
    } else if (phase === 'TRACK'){
      ctx.fillText('Tracking — mouvement', 24, window.innerHeight-24);
    } else if (phase === 'REVEAL'){
      ctx.fillText('Cibles = rouge + contour vert', 24, window.innerHeight-24);
    }
  }

  function drawGrid(){
    for (const cell of grid){
      const w = CONFIG.size*4.0;
      const h = CONFIG.size*2.5;

      // roundRect simple (compatible)
      ctx.beginPath();
      roundRect(ctx, cell.x - w/2, cell.y - h/2, w, h, 14);
      ctx.fillStyle = 'rgba(255,255,255,.05)';
      ctx.fill();
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = 'rgba(255,255,255,.08)';
      ctx.stroke();

      ctx.fillStyle = cell.color;
      ctx.font = `${Math.max(14, CONFIG.size)}px system-ui, -apple-system, Segoe UI, Roboto`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(cell.text, cell.x, cell.y);
    }
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
  }

  function roundRect(c, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    c.moveTo(x+r, y);
    c.arcTo(x+w, y, x+w, y+h, r);
    c.arcTo(x+w, y+h, x, y+h, r);
    c.arcTo(x, y+h, x, y, r);
    c.arcTo(x, y, x+w, y, r);
    c.closePath();
  }

  function loop(now){
    if (!running) { draw(now); return; }

    const dt = (now - last)/1000;
    last = now;
    const ms = now - t0;

    if (CONFIG.mode === 'tracker'){
      if (phase === 'CUE' && ms >= CONFIG.preMoveMs){
        phase = 'TRACK';
        phaseEl.textContent = phase;
      }
      if (phase === 'TRACK'){
        stepTracker(dt);
      }
      if (phase === 'TRACK' && ms >= (CONFIG.preMoveMs + CONFIG.moveMs)){
        stopRun(now);
      }
    } else if (CONFIG.mode === 'grid'){
      const gridCueMs = 700;
      if (phase === 'CUE' && ms >= gridCueMs){
        phase = 'TRACK';
        phaseEl.textContent = phase;
      }
      if (phase === 'CUE' || phase === 'TRACK') stepGrid(dt);
      if (phase === 'TRACK' && ms >= (gridCueMs + CONFIG.moveMs)) stopRun(now);
    } else {
      // ✅ colors : infini
      if (now - lastColorChangeAt >= CONFIG.colorIntervalMs){
        lastColorChangeAt = now;

        // évite de tirer 2x la même suite
        let idx = (Math.random()*COLOR_SET.length)|0;
        const pick = COLOR_SET[idx];
        currentColor = pick.value;
        currentColorName = pick.name;
      }
      // pas d'auto-stop
      phase = 'TRACK';
      phaseEl.textContent = phase;

      const elapsed = (now - t0) / 1000;
      timeEl.textContent = elapsed.toFixed(2);
      fillEl.style.width = '0%';
    }

    draw(now);
    if (running) requestAnimationFrame(loop);
  }

  // ===== Controls =====
  startBtn.addEventListener('click', () => safeAction(performance.now()));
  revealBtn.addEventListener('click', () => safeAction(performance.now()));

  stopBtn.addEventListener('click', () => {
    const now = performance.now();
    if (running) stopRun(now);
    else {
      // en colors, stop = start
      if (CONFIG.mode === 'colors') startRun();
      else if (phase === 'STOP') reveal(now);
    }
  });

  overlayStart.addEventListener('click', () => startRun());
  overlayMenu.addEventListener('click', () => drawer.classList.add('open'));

  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    safeAction(performance.now());
  }, { passive:false });

  document.addEventListener('keydown', (e) => {
    const key = e.key;
    const code = e.code;
    if (code === 'Space' || key === ' ' || key === 'Spacebar'){
      e.preventDefault();
      safeAction(performance.now());
    }
    const k = (key || '').toLowerCase();
    if (k === 'm') drawer.classList.toggle('open');
    if (k === 'n') newTrial();
  });

  window.addEventListener('error', (ev) => {
    setError(`Erreur JS détectée:\n${ev.message}\n${ev.filename}:${ev.lineno}`);
  });

  modeSel.addEventListener('change', () => { applyFromControls(); newTrial(); });

  function initDefaults(){
    speedSlider.value = CONFIG.speed;
    moveSlider.value = Math.round(CONFIG.moveMs/1000);
    sizeSlider.value = CONFIG.size;

    fixationSel.value = CONFIG.fixation;
    gamifySel.value = CONFIG.gamify;

    stimulusSel.value = CONFIG.stimulus;
    preMoveSlider.value = (CONFIG.preMoveMs/1000);

    nSlider.value = CONFIG.nDots;
    tSlider.value = CONFIG.nTargets;
    chaosSlider.value = CONFIG.chaos;

    gridSizeSel.value = String(CONFIG.gridN);
    gridColorModeSel.value = CONFIG.gridColorMode;

    colorIntervalSlider.value = (CONFIG.colorIntervalMs/1000).toFixed(2);
  }

  initDefaults();
  applyFromControls();
  resizeCanvas();
  newTrial();
})();
</script>
</body>
</html>
